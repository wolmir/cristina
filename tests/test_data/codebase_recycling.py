import os
import ast
import pyck
import shutil
import symtable
from astmonkey import visitors
from static_class_decorator import staticclass


class SourceGeneratorNodeVisitorFix(visitors.SourceGeneratorNodeVisitor):
    def visit_TryExcept(self, node):
        self.newline(node)
        self.write('try:')
        self.body(node.body)
        for handler in node.handlers:
            self.visit(handler)
        if node.orelse:
            self.newline()
            self.write('else:')
            self.body(node.orelse)

def to_source(node, indent_with=' ' * 4):
    """This function can convert a node tree back into python sourcecode.
    This is useful for debugging purposes, especially if you're dealing with
    custom asts not generated by python itself.

    It could be that the sourcecode is evaluable when the AST itself is not
    compilable / evaluable.  The reason for this is that the AST contains some
    more data than regular sourcecode does, which is dropped during
    conversion.

    Each level of indentation is replaced with `indent_with`.  Per default this
    parameter is equal to four spaces as suggested by PEP 8, but it might be
    adjusted to match the application's styleguide.
    """
    generator = SourceGeneratorNodeVisitorFix(indent_with)
    generator.visit(node)

    return  ''.join(generator.result)


class ResetLinesVisitor(ast.NodeVisitor):
    def visit(self, node):
        if hasattr(node, 'lineno'):
            node.lineno = node.lineno
        ast.NodeVisitor.visit(self, node)

    def visit_ClassDef(self, node):
        node.lineno = node.lineno
        self.generic_visit(node)


class AstWrapperClass:
    def __init__(self, class_ast_node=None):
        self.class_ast_node = class_ast_node
        if not self.class_ast_node:
            self.class_ast_node = ast.ClassDef()
            self.class_ast_node.name = ''
            self.class_ast_node.body = []
            self.class_ast_node.bases = []
            self.class_ast_node.decorator_list = []

    def get_ast_node(self):
        return self.class_ast_node

    def __reset_line_numbers(self):
        ast.fix_missing_locations(self.class_ast_node)
        ResetLinesVisitor().visit(self.class_ast_node)

    def get_instance_variables(self, class_symbol_table):
        symbol_extractor = pyck.InstanceSymbolsExtractor(self.get_ast_node(), class_symbol_table)
        symbol_extractor.extract()
        return symbol_extractor.instance_references

    def get_instance_variables_per_method(self, class_symbol_table):
        symbol_extractor = pyck.InstanceSymbolsExtractor(self.get_ast_node(), class_symbol_table)
        symbol_extractor.extract()
        instance_variables_per_method = symbol_extractor.instance_variables_per_method
        try:
            del instance_variables_per_method['__init__']
        except KeyError:
            pass
        return instance_variables_per_method.items()

    def copy(self):
        temporary_code = to_source(self.class_ast_node)
        ast_node_copy = ast.parse(temporary_code).body[0]
        wrapper_class_copy = AstWrapperClass(ast_node_copy)
        return wrapper_class_copy

    def create_init_method(self, fields_to_be_initialized):
        method_node = ast.FunctionDef()
        method_node.name = '__init__'
        method_node.args = AstWrapperClass.empty_arguments()
        method_node.body = AstWrapperClass.create_init_assignment_nodes_from_fields(fields_to_be_initialized)
        method_node.decorator_list = []
        self.add_methods([method_node])
        self.__reset_line_numbers()

    @staticmethod
    def empty_arguments():
        arguments = ast.arguments()
        arguments.args = []
        arguments.vararg = None
        arguments.kwarg = None
        arguments.defaults = []
        return arguments

    @staticmethod
    def create_init_assignment_nodes_from_fields(fields):
        assign_nodes = []
        for field in fields:
            field_as_attribute = ast.Attribute()
            field_as_attribute.value = ast.Name(id='self', ctx=ast.Load())
            field_as_attribute.attr = field
            field_as_attribute.ctx = ast.Store()
            assign_node = ast.Assign()
            assign_node.targets = [field_as_attribute]
            assign_node.value = ast.Name(id='None', ctx=ast.Load())
            assign_nodes.append(assign_node)
        return assign_nodes

    @staticmethod
    def create_assignment_nodes_from_fields(fields):
        assign_nodes = []
        for field in fields:
            field_as_name = ast.Name(id=field, ctx=ast.Load())
            assign_node = ast.Assign()
            assign_node.targets = [field_as_name]
            assign_node.value = ast.Name(id='None', ctx=ast.Load())
            assign_nodes.append(assign_node)
        return assign_nodes

    def add_instance_variables(self, fields):
        assign_nodes = AstWrapperClass.create_assignment_nodes_from_fields(fields)
        self.class_ast_node.body = assign_nodes + self.class_ast_node.body

    def get_class_name(self):
        return self.class_ast_node.name

    def get_class_name_as_node(self):
        return ast.Name(id=self.class_ast_node.name, ctx=ast.Load())

    def set_class_name(self, name):
        self.class_ast_node.name = name

    def find_method_nodes(self, method_names):
        class MethodFinder(ast.NodeVisitor):
            def __init__(self):
                ast.NodeVisitor.__init__(self)
                self.method_nodes = []

            def visit_FunctionDef(self, node):
                if node.name in method_names:
                    self.method_nodes.append(node)

        method_finder = MethodFinder()
        method_finder.visit(self.class_ast_node)
        return method_finder.method_nodes

    def add_methods(self, method_nodes):
        for method_node in method_nodes:
            if not method_node in self.class_ast_node.body:
                self.class_ast_node.body.append(method_node)
        self.__reset_line_numbers()

    def remove_methods(self, method_nodes):
        for method_node in method_nodes:
            if method_node in self.class_ast_node.body:
                self.class_ast_node.body.remove(method_node)
        self.__reset_line_numbers()

    def get_superclasses(self):
        return self.class_ast_node.bases

    def set_superclasses(self, base_nodes):
        self.class_ast_node.bases = base_nodes

    def is_subclass_of(self, superclass_name):
        for base_node in self.get_superclasses():
            if hasattr(base_node, 'id'):
                if base_node.id == superclass_name:
                    return True
            if hasattr(base_node, 'name'):
                if base_node.name == superclass_name:
                    return True
        return False

    def is_property(self, field):
        properties = self.get_property_attributes_for_fields([field])
        return len(properties) > 0

    def get_property_attributes_for_fields(self, fields):
        class PropertyFinder(ast.NodeVisitor):
            def __init__(self):
                ast.NodeVisitor.__init__(self)
                self.properties = []

            # def visit(self, node):
            #     self.generic_visit(node)

            def visit_Name(self, node):
                if node.id == 'property':
                    return True
                return node.id in fields

            def visit_Call(self, node):
                return self.visit(node.func)

            def visit_Assign(self, node):
                if self.visit(node.value):
                    if self.visit(node.targets[0]):
                        self.properties.append(node)

        property_finder = PropertyFinder()
        property_finder.visit(self.class_ast_node)
        return property_finder.properties

    def add_properties(self, properties):
        self.class_ast_node.body += properties

    def __create_assignment_from_superclass(self, field):
        superclass_name = 'object'
        if len(self.class_ast_node.bases) > 0:
            superclass_name = self.class_ast_node.bases[0].id
        attribute = ast.Attribute()
        attribute.value = ast.Name(id=superclass_name, ctx=ast.Load())
        attribute.attr = field
        attribute.ctx = ast.Load()
        assignment = ast.Assign()
        assignment.targets = [ast.Name(id=field, ctx=ast.Store())]
        assignment.value = attribute
        return assignment

    def get_property_methods(self, property_node):
        method_names = [name.id for name in property_node.value.args]
        property_methods = []
        for method_name in method_names:
            methods = self.find_method_nodes([method_name])
            if len(methods) == 0:
                property_methods.append(self.__create_assignment_from_superclass(method_name))
            else:
                property_methods.append(methods[0])
        return property_methods

    def remove_properties(self, property_nodes):
        for node in property_nodes:
            self.class_ast_node.body.remove(node)


@staticclass
class SuperClassExtractor:
    def __init__(self):
        pass

    class CohesionOfMethodsException(Exception):
        def __init__(self, class_name):
            Exception.__init__(self, class_name + ' has no more disjoint methods.')

    @staticmethod
    def extract_by_cohesion(class_ast_node, class_symbol_table, superclass_name):
        subclass = AstWrapperClass(class_ast_node)
        methods_as_sets_of_instance_variables = subclass.get_instance_variables_per_method(class_symbol_table)
        if len(methods_as_sets_of_instance_variables) == 0:
            raise SuperClassExtractor.CohesionOfMethodsException(subclass.get_class_name())
        # Cohesion in this case means the number of instance
        # variables referenced in the method.
        method_tuples_sorted_by_cohesion = sorted(methods_as_sets_of_instance_variables, key=lambda x: len(x[1]))
        superclass_fields = method_tuples_sorted_by_cohesion[0][1]
        superclass_methods = [method[0] for method in method_tuples_sorted_by_cohesion
                              if method[1] == superclass_fields]
        if len(superclass_methods) == len(method_tuples_sorted_by_cohesion):
            raise SuperClassExtractor.CohesionOfMethodsException(subclass.get_class_name())
        return SuperClassExtractor.extract_superclass(subclass, superclass_name, superclass_fields, superclass_methods)

    @staticmethod
    def extract_superclass(subclass, superclass_name, superclass_fields, superclass_methods):
        superclass = AstWrapperClass()
        superclass.set_class_name(superclass_name)
        modified_subclass = subclass.copy()
        exposed_fields = [field for field in superclass_fields if not modified_subclass.is_property(field)]
        superclass.add_instance_variables(exposed_fields)
        property_fields = modified_subclass.get_property_attributes_for_fields(superclass_fields)
        for property_field in property_fields:
            property_methods = modified_subclass.get_property_methods(property_field)
            superclass.add_methods(property_methods)
            modified_subclass.remove_methods(property_methods)
        modified_subclass.remove_properties(property_fields)
        superclass.add_properties(property_fields)
        method_nodes = modified_subclass.find_method_nodes(superclass_methods)
        superclass.add_methods(method_nodes)
        modified_subclass.remove_methods(method_nodes)
        grandparent_classes = modified_subclass.get_superclasses()
        superclass.set_superclasses(grandparent_classes)
        modified_subclass.set_superclasses([superclass.get_class_name_as_node()])
        return superclass.get_ast_node(), modified_subclass.get_ast_node()

    @staticmethod
    def extract_into_ideal_cohesion(class_ast_node, class_symbol_table):
        superclasses = []
        subclass = class_ast_node
        subclass_name = AstWrapperClass(class_ast_node).get_class_name()

        try:
            iteration_number = 0
            while True:
                superclass_name = subclass_name + 'Super' + str(iteration_number)
                superclass, subclass = SuperClassExtractor.\
                    extract_by_cohesion(subclass, class_symbol_table, superclass_name)
                superclasses.append(superclass)
                iteration_number += 1
        except SuperClassExtractor.CohesionOfMethodsException:
            pass

        return superclasses, subclass


class CodeBaseRecycler:
    def __init__(self, codebase_path):
        self.codebase_path = codebase_path
        self.output_directory = None

    def set_output_directory(self, output_directory):
        self.output_directory = output_directory
        shutil.copytree(self.codebase_path, self.output_directory)

    def recycle(self):
        modules = self.get_modules()
        for module in modules:
            recycled_module = self.recycle_module(module)
            self.output(recycled_module)

    def get_modules(self):
        modules = []

        def visit_for_modules(arg, dirname, names):
            module_names = [name for name in names if name.endswith('.py')]
            module_paths = [os.path.join(dirname, name) for name in module_names]
            arg += [ModuleWrapper(module_path) for module_path in module_paths]

        os.path.walk(self.codebase_path, visit_for_modules, modules)
        return modules

    def recycle_module(self, module_wrapper):
        ast_classes = module_wrapper.pop_classes()
        symbol_tables = module_wrapper.get_symbol_tables()
        for index, ast_class in enumerate(ast_classes):
            ast_superclasses, ast_subclass = SuperClassExtractor.\
                extract_into_ideal_cohesion(ast_class, symbol_tables[index])
            module_wrapper.insert_classes(ast_superclasses + [ast_subclass])
        return module_wrapper

    def output(self, module_wrapper):
        file_path = module_wrapper.get_file_path()
        file_path = file_path.replace(self.codebase_path, self.output_directory)
        with open(file_path, 'w') as source_file:
            source_code = module_wrapper.get_source_code()
            source_file.write(source_code)


class ModuleWrapper:
    def __init__(self, module_source_file_path):
        self.file_path = module_source_file_path
        self.ast_node = self.__parse_module_ast()
        self.class_nodes = self.__find_class_nodes()
        self.symbol_tables = self.__find_class_symbol_tables()
        self.__fix_import_locations()
        self.__fix_line_numbers()

    def __fix_line_numbers(self):
        ResetLinesVisitor().visit(self.ast_node)

    @staticmethod
    def __fix_class_definitions_order(class_definitions):
        pass

    def pop_classes(self):
        self.__remove_class_nodes()
        return self.class_nodes

    def insert_classes(self, ast_class_nodes):
        last_import_index = self.__last_import_index()
        module_body_import_segment = self.ast_node.body[:last_import_index]
        module_body_classes_segment = ast_class_nodes
        module_body_tail_segment = self.ast_node.body[last_import_index:]
        self.ast_node.body = module_body_import_segment + module_body_classes_segment + module_body_tail_segment
        self.__fix_line_numbers()

    def __last_import_index(self):
        for index, statement in enumerate(self.ast_node.body):
            is_not_import = not isinstance(statement, ast.Import)
            is_not_import_from = not isinstance(statement, ast.ImportFrom)
            if is_not_import and is_not_import_from:
                return index
        return 0

    def __fix_import_locations(self):
        import_statements = self.__get_import_statements()
        for statement in import_statements:
            self.ast_node.body.remove(statement)
        self.ast_node.body = import_statements + self.ast_node.body

    def __get_import_statements(self):
        import_statements = []
        for statement in self.ast_node.body:
            is_import = isinstance(statement, ast.Import)
            is_import_from = isinstance(statement, ast.ImportFrom)
            if is_import or is_import_from:
                import_statements.append(statement)
        return import_statements

    def __parse_module_ast(self):
        with open(self.file_path) as source_file:
            ast_node = ast.parse(source_file.read())
        return ast_node

    def __find_class_nodes(self):
        class ClassFinder(ast.NodeVisitor):
            def __init__(self):
                ast.NodeVisitor.__init__(self)
                self.classes = []

            def visit_ClassDef(self, node):
                self.classes.append(node)

        class_finder = ClassFinder()
        class_finder.visit(self.ast_node)
        return class_finder.classes

    def __find_class_symbol_tables(self):
        class_names = self.__get_class_names()
        source_code = self.get_source_code()
        module_symbol_table = symtable.symtable(source_code, self.file_path, 'exec')
        symbol_tables = []
        for name in class_names:
            class_symbol_table = module_symbol_table.lookup(name).get_namespace()
            symbol_tables.append(class_symbol_table)
        return symbol_tables

    def __remove_class_nodes(self):
        class ClassNodeExterminator(ast.NodeTransformer):
            def __init__(self, class_names):
                ast.NodeTransformer.__init__(self)
                self.class_names = class_names

            def visit_ClassDef(self, node):
                if node.name in self.class_names:
                    return None

        ClassNodeExterminator(self.__get_class_names()).visit(self.ast_node)

    def __get_class_names(self):
        return [node.name for node in self.class_nodes]

    def get_source_code(self):
        return to_source(self.ast_node)

    def get_symbol_tables(self):
        return self.symbol_tables

    def get_file_path(self):
        return self.file_path


def __tests():
    import symtable

    class ClassFinder(ast.NodeVisitor):
        def __init__(self, name):
            ast.NodeVisitor.__init__(self)
            self.name = name
            self.classes = []

        def visit_ClassDef(self, node):
            if node.name == self.name:
                self.classes.append(node)

    with open('tests/game2.py') as source_file:
        code = source_file.read()
        ast_node = ast.parse(code)
        symbol_table = symtable.symtable(code, 'game2.py', 'exec')
        class_finder = ClassFinder('Game')
        class_finder.visit(ast_node)
        subclass = class_finder.classes[0]
        subclass_symbol_table = symbol_table.lookup('Game').get_namespace()
        superclasses, subclass = SuperClassExtractor.extract_into_ideal_cohesion(subclass, subclass_symbol_table)
        for superclass_node in superclasses:
            print to_source(superclass_node)
            # print
            # print ast.dump(superclass_node)
            print
            print '#' * 200
            print
        print to_source(subclass)
        # print to_source(superclass)
        # print "#" * 200
        # print to_source(subclass)


def __test_recycler():
    current_directory = os.getcwd()
    try:
        recycler = CodeBaseRecycler(os.path.join(current_directory, 'tests', 'game_prototypes'))
        recycler.set_output_directory(os.path.join(current_directory, 'tests', 'recycled_codebase'))
        recycler.recycle()
    except:
        shutil.rmtree(os.path.join(current_directory, 'tests', 'recycled_codebase'))
        raise

if __name__ == '__main__':
    __test_recycler()